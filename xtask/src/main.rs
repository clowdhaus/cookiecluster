use std::{env, fs, io::Write};

use anyhow::Result;
use aws_sdk_ec2::types::{ArchitectureType, UsageClassType};
use handlebars::Handlebars;
use serde::{Deserialize, Serialize};
use serde_json::json;
use tracing_subscriber::{filter::LevelFilter, FmtSubscriber};

#[tokio::main]
async fn main() -> Result<()> {
  let subscriber = FmtSubscriber::builder()
    .with_max_level(LevelFilter::WARN)
    .without_time()
    .pretty()
    .finish();
  tracing::subscriber::set_global_default(subscriber).expect("Setting default subscriber failed");

  if let Err(e) = try_main().await {
    eprintln!("{e}");
    std::process::exit(-1);
  }

  Ok(())
}

async fn try_main() -> Result<()> {
  let task = env::args().nth(1);

  match task.as_deref() {
    Some("update-ec2") => update_ec2_instances().await?,
    _ => print_help(),
  }
  Ok(())
}

fn print_help() {
  eprintln!(
    "Tasks:

update-ec2 -> Collect and update EC2 instances embedded into the CLI for autocompletion
"
  )
}

#[derive(Debug, Serialize, Deserialize)]
struct InstanceInfo {
  instance_type: String,
  /// Supports instance storage (ephemeral storage)
  instance_storage_supported: bool,
  /// Supports Amazon Elastic Fabric Adapter (EFA)
  efa_supported: bool,
  /// Supports NVIDIA GPUs
  gpu_supported: bool,
  /// Supports AWS Neuron devices found on Inferentia and Trainium
  neuron_supported: bool,
  /// Supports ML capacity-block reservation
  cbr_supported: bool,
  os_arch: String,
}

static EC2_INSTANCES_TEMPLATE: &str = "/// Generated by `cargo xtask update-ec2`

#[derive(Debug)]
pub struct InstanceInfo<'a> {
  pub instance_type: &'a str,
  /// Supports instance storage (ephemeral storage)
  pub instance_storage_supported: bool,
  /// Supports Amazon Elastic Fabric Adapter (EFA)
  pub efa_supported: bool,
  /// Supports NVIDIA GPUs
  pub gpu_supported: bool,
  /// Supports AWS Neuron devices found on Inferentia and Trainium
  pub neuron_supported: bool,
  /// Supports ML capacity-block reservation
  pub cbr_supported: bool,
  /// Operating system architecture
  pub os_arch: &'a str,
}

/// AWS EC2 instance types
pub const INSTANCE_TYPES: &[InstanceInfo] = &[
{{ #each instances as |instance| }}
  InstanceInfo {
    instance_type: \"{{ instance.instance_type }}\",
    instance_storage_supported: {{ instance.instance_storage_supported }},
    efa_supported: {{ instance.efa_supported }},
    gpu_supported: {{ instance.gpu_supported }},
    neuron_supported: {{ instance.neuron_supported }},
    cbr_supported: {{ instance.cbr_supported }},
    os_arch: \"{{ instance.os_arch }}\",
  },
{{ /each }}
];
";

/// Generate the CRD and copy it into the Helm chart directory
async fn update_ec2_instances() -> Result<()> {
  let config = aws_config::load_from_env().await;
  let client = aws_sdk_ec2::Client::new(&config);

  let mut instances = client
    .describe_instance_types()
    .into_paginator()
    .items()
    .send()
    .collect::<Result<Vec<_>, _>>()
    .await?
    .into_iter()
    .map(|info| {
      let efa_supported = info.network_info.as_ref().unwrap().efa_supported.unwrap_or(false);
      let gpu_supported = info.gpu_info.is_some();
      let neuron_supported = info.neuron_info.is_some();
      let cbr_supported = info
        .supported_usage_classes
        .unwrap()
        .contains(&UsageClassType::CapacityBlock);
      let os_arches = info.processor_info.unwrap().supported_architectures.unwrap();
      let os_arch = if os_arches.contains(&ArchitectureType::Arm64) | os_arches.contains(&ArchitectureType::Arm64Mac) {
        "arm64".to_owned()
      } else if os_arches.contains(&ArchitectureType::X8664) | os_arches.contains(&ArchitectureType::X8664Mac) {
        "x86_64".to_owned()
      } else {
        "unknown".to_owned()
      };

      InstanceInfo {
        instance_type: info.instance_type.unwrap().as_str().to_owned(),
        instance_storage_supported: info.instance_storage_supported.unwrap(),
        efa_supported,
        gpu_supported,
        neuron_supported,
        cbr_supported,
        os_arch,
      }
    })
    .collect::<Vec<InstanceInfo>>();
  instances.sort_by_key(|i| i.instance_type.clone());

  let reg = Handlebars::new();
  let rendered = reg.render_template(EC2_INSTANCES_TEMPLATE, &json!({"instances": instances}))?;

  let mut file = fs::OpenOptions::new()
    .create(true)
    .truncate(true)
    .write(true)
    .open("./cc/src/instances.rs")?;

  file.write_all(rendered.as_bytes())?;

  Ok(())
}
