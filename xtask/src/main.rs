use std::{collections::BTreeMap, env, fs, io::Write};

use anyhow::Result;
use aws_sdk_ec2::types::{ArchitectureType, UsageClassType};
use aws_types::region::Region;
use handlebars::Handlebars;
use serde::{Deserialize, Serialize};
use serde_json::json;
use tracing_subscriber::{filter::LevelFilter, FmtSubscriber};

#[tokio::main]
async fn main() -> Result<()> {
  let subscriber = FmtSubscriber::builder()
    .with_max_level(LevelFilter::WARN)
    .without_time()
    .pretty()
    .finish();
  tracing::subscriber::set_global_default(subscriber).expect("Setting default subscriber failed");

  if let Err(e) = try_main().await {
    eprintln!("{e}");
    std::process::exit(-1);
  }

  Ok(())
}

async fn try_main() -> Result<()> {
  let task = env::args().nth(1);

  match task.as_deref() {
    Some("update-ec2") => update_ec2_instances().await?,
    _ => print_help(),
  }
  Ok(())
}

fn print_help() {
  eprintln!(
    "Tasks:

update-ec2 -> Collect and update EC2 instances embedded into the CLI for autocompletion
"
  )
}

#[derive(Debug, Serialize, Deserialize)]
struct InstanceInfo {
  instance_type: String,
  /// Supports instance storage (ephemeral storage)
  instance_storage_supported: bool,
  /// Supports Amazon Elastic Fabric Adapter (EFA)
  efa_supported: bool,
  /// Supports NVIDIA GPUs
  gpu_supported: bool,
  /// Supports AWS Neuron devices found on Inferentia and Trainium
  neuron_supported: bool,
  /// Supports ML capacity-block reservation
  cbr_supported: bool,
  os_arch: String,
}

static EC2_INSTANCES_TEMPLATE: &str = "/// Generated by `cargo xtask update-ec2`

#[derive(Debug)]
pub struct InstanceInfo<'a> {
  pub instance_type: &'a str,
  /// Supports instance storage (ephemeral storage)
  pub instance_storage_supported: bool,
  /// Supports Amazon Elastic Fabric Adapter (EFA)
  pub efa_supported: bool,
  /// Supports NVIDIA GPUs
  pub gpu_supported: bool,
  /// Supports AWS Neuron devices found on Inferentia and Trainium
  pub neuron_supported: bool,
  /// Supports ML capacity-block reservation
  pub cbr_supported: bool,
  /// Operating system architecture
  pub os_arch: &'a str,
}

/// AWS EC2 instance types
pub const INSTANCE_TYPES: &[InstanceInfo] = &[
{{ #each instances as |instance| }}
  InstanceInfo {
    instance_type: \"{{ instance.instance_type }}\",
    instance_storage_supported: {{ instance.instance_storage_supported }},
    efa_supported: {{ instance.efa_supported }},
    gpu_supported: {{ instance.gpu_supported }},
    neuron_supported: {{ instance.neuron_supported }},
    cbr_supported: {{ instance.cbr_supported }},
    os_arch: \"{{ instance.os_arch }}\",
  },
{{ /each }}
];
";

/// Get EC2 instance details for the given region provided
async fn get_ec2_instances(
  region: Region,
  mut instances: BTreeMap<String, InstanceInfo>,
) -> Result<BTreeMap<String, InstanceInfo>> {
  let config = aws_config::from_env().region(region).load().await;
  let client = aws_sdk_ec2::Client::new(&config);

  let instances_info = client
    .describe_instance_types()
    .into_paginator()
    .items()
    .send()
    .collect::<Result<Vec<_>, _>>()
    .await?;

  for inst in instances_info.iter() {
    let efa_supported = inst.network_info.as_ref().unwrap().efa_supported.unwrap_or(false);
    let gpu_supported = inst.gpu_info.is_some();
    let neuron_supported = inst.neuron_info.is_some();
    let cbr_supported = inst
      .supported_usage_classes
      .to_owned()
      .unwrap()
      .contains(&UsageClassType::CapacityBlock);
    let os_arches = inst.processor_info.to_owned().unwrap().supported_architectures.unwrap();
    let os_arch = if os_arches.contains(&ArchitectureType::Arm64) | os_arches.contains(&ArchitectureType::Arm64Mac) {
      "arm64".to_owned()
    } else if os_arches.contains(&ArchitectureType::X8664) | os_arches.contains(&ArchitectureType::X8664Mac) {
      "x86_64".to_owned()
    } else {
      "unknown".to_owned()
    };

    let instance_type = inst.instance_type.to_owned().unwrap().as_str().to_owned();
    instances.insert(
      instance_type.clone(),
      InstanceInfo {
        instance_type,
        instance_storage_supported: inst.instance_storage_supported.unwrap(),
        efa_supported,
        gpu_supported,
        neuron_supported,
        cbr_supported,
        os_arch,
      },
    );
  }

  Ok(instances)
}

/// Collect the EC2 instance details and populate the instances.rs file
async fn update_ec2_instances() -> Result<()> {
  let regions = vec!["us-east-1", "us-west-2"];
  let mut instances: BTreeMap<String, InstanceInfo> = BTreeMap::new();

  // Not GA and requires allow listing
  instances.insert(
    "p4de.24xlarge".to_owned(),
    InstanceInfo {
      instance_type: "p4de.24xlarge".to_owned(),
      instance_storage_supported: true,
      efa_supported: true,
      gpu_supported: true,
      neuron_supported: false,
      cbr_supported: false,
      os_arch: "x86_64".to_owned(),
    },
  );

  for region in regions {
    instances = get_ec2_instances(Region::new(region.to_owned()), instances).await?;
  }

  let reg = Handlebars::new();
  let rendered = reg.render_template(EC2_INSTANCES_TEMPLATE, &json!({"instances": instances}))?;

  let mut file = fs::OpenOptions::new()
    .create(true)
    .truncate(true)
    .write(true)
    .open("./cc/src/instances.rs")?;

  file.write_all(rendered.as_bytes())?;

  Ok(())
}
