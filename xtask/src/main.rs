use std::{env, fs, io::Write};

use anyhow::Result;
use tracing_subscriber::{filter::LevelFilter, FmtSubscriber};

#[tokio::main]
async fn main() -> Result<()> {
  let subscriber = FmtSubscriber::builder()
    .with_max_level(LevelFilter::WARN)
    .without_time()
    .pretty()
    .finish();
  tracing::subscriber::set_global_default(subscriber).expect("Setting default subscriber failed");

  if let Err(e) = try_main().await {
    eprintln!("{e}");
    std::process::exit(-1);
  }

  Ok(())
}

async fn try_main() -> Result<()> {
  let task = env::args().nth(1);

  match task.as_deref() {
    Some("update-ec2") => update_ec2_instances().await?,
    _ => print_help(),
  }
  Ok(())
}

fn print_help() {
  eprintln!(
    "Tasks:

update-ec2 -> Collect and update EC2 instances embedded into the CLI for autocompletion
"
  )
}

/// Generate the CRD and copy it into the Helm chart directory
async fn update_ec2_instances() -> Result<()> {
  let config = aws_config::load_from_env().await;
  let client = aws_sdk_ec2::Client::new(&config);

  let mut results = client
    .describe_instance_types()
    .into_paginator()
    .items()
    .send()
    .collect::<Result<Vec<_>, _>>()
    .await?
    .into_iter()
    .map(|info| info.instance_type.unwrap().as_str().to_owned())
    .collect::<Vec<String>>();
  results.sort();
  let results = results.join("\",\n  \"");

  let mut file = fs::OpenOptions::new()
    .create(true)
    .truncate(true)
    .write(true)
    .open("./cc/src/instances.rs")?;

  let tmpl = format!(
    "/// Generated by `cargo xtask update-ec2`

/// AWS EC2 instance types
pub const INSTANCE_TYPES: &[&str] = &[
  \"{results}\"
];
"
  );

  file.write_all(tmpl.as_bytes())?;

  Ok(())
}
