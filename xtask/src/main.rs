use std::{collections::BTreeMap, env, fs, io::Write};

use anyhow::Result;
use aws_sdk_ec2::types::{ArchitectureType, Filter, UsageClassType};
use aws_types::region::Region;
use handlebars::Handlebars;
use serde::{Deserialize, Serialize};
use serde_json::json;
use tracing_subscriber::{FmtSubscriber, filter::LevelFilter};

#[tokio::main]
async fn main() -> Result<()> {
  let subscriber = FmtSubscriber::builder()
    .with_max_level(LevelFilter::WARN)
    .without_time()
    .pretty()
    .finish();
  tracing::subscriber::set_global_default(subscriber).expect("Setting default subscriber failed");

  if let Err(e) = try_main().await {
    eprintln!("{e}");
    std::process::exit(-1);
  }

  Ok(())
}

async fn try_main() -> Result<()> {
  let task = env::args().nth(1);

  match task.as_deref() {
    Some("update-ec2") => update_ec2_instances().await?,
    _ => print_help(),
  }
  Ok(())
}

fn print_help() {
  eprintln!(
    "Tasks:

update-ec2 -> Collect and update EC2 instances embedded into the CLI for autocompletion
"
  )
}

#[derive(Debug, Serialize, Deserialize)]
struct InstanceInfo {
  instance_type: String,
  /// Supports instance storage (ephemeral storage)
  instance_storage_supported: bool,
  /// Supports Amazon Elastic Fabric Adapter (EFA)
  efa_supported: bool,
  /// Supports NVIDIA GPUs
  nvidia_gpu_supported: bool,
  /// Supports AWS Neuron devices found on Inferentia and Trainium
  neuron_supported: bool,
  /// Supports ML capacity-block reservation
  cbr_supported: bool,
  cpu_arch: String,
}

static EC2_INSTANCES_TEMPLATE: &str = "/// Generated by `cargo xtask update-ec2`

#[derive(Debug)]
pub struct InstanceInfo<'a> {
  pub instance_type: &'a str,
  /// Supports instance storage (ephemeral storage)
  pub instance_storage_supported: bool,
  /// Supports Amazon Elastic Fabric Adapter (EFA)
  pub efa_supported: bool,
  /// Supports NVIDIA GPUs
  pub nvidia_gpu_supported: bool,
  /// Supports AWS Neuron devices found on Inferentia and Trainium
  pub neuron_supported: bool,
  /// Supports ML capacity-block reservation
  pub cbr_supported: bool,
  /// CPU chipset architecture
  pub cpu_arch: &'a str,
}

/// AWS EC2 instance types
pub const INSTANCE_TYPES: &[InstanceInfo] = &[
{{ #each instances as |instance| }}
  InstanceInfo {
    instance_type: \"{{ instance.instance_type }}\",
    instance_storage_supported: {{ instance.instance_storage_supported }},
    efa_supported: {{ instance.efa_supported }},
    nvidia_gpu_supported: {{ instance.nvidia_gpu_supported }},
    neuron_supported: {{ instance.neuron_supported }},
    cbr_supported: {{ instance.cbr_supported }},
    cpu_arch: \"{{ instance.cpu_arch }}\",
  },
{{ /each }}
];
";

/// Get EC2 instance details for the given region provided
async fn get_ec2_instances(
  region: Region,
  mut instances: BTreeMap<String, InstanceInfo>,
) -> Result<BTreeMap<String, InstanceInfo>> {
  let config = aws_config::from_env().region(region).load().await;
  let client = aws_sdk_ec2::Client::new(&config);

  let instances_info = client
    .describe_instance_types()
    .filters(Filter::builder().name("current-generation").values("true").build())
    .filters(Filter::builder().name("bare-metal").values("false").build())
    .into_paginator()
    .items()
    .send()
    .collect::<Result<Vec<_>, _>>()
    .await?;

  for inst in instances_info.iter() {
    let itype = inst.instance_type().unwrap().as_str();
    match itype {
      _ if itype.starts_with("d")
        | itype.starts_with("f")
        | itype.starts_with("gr")
        | itype.starts_with("h1")
        | itype.starts_with("i3")
        | itype.starts_with("i4")
        | itype.starts_with("i7")
        | itype.starts_with("i8")
        | itype.starts_with("im")
        | itype.starts_with("inf1")
        | itype.starts_with("is")
        | itype.starts_with("p2")
        | itype.starts_with("t2")
        | itype.starts_with("t3")
        | itype.starts_with('u')
        | itype.starts_with("v")
        | itype.starts_with("x")
        | itype.starts_with("z") =>
      {
        continue;
      }
      _ => {}
    }

    let efa_supported = inst.network_info.as_ref().unwrap().efa_supported.unwrap_or(false);

    let gpu_manufacturer = match inst.gpu_info.as_ref() {
      Some(gpu_info) => gpu_info
        .gpus
        .as_ref()
        .unwrap()
        .first()
        .unwrap()
        .manufacturer
        .as_ref()
        .unwrap()
        .to_string(),
      None => "none".to_string(),
    };
    let nvidia_gpu_supported = gpu_manufacturer == "NVIDIA";
    let neuron_supported = inst.neuron_info.is_some();
    let cbr_supported = inst
      .supported_usage_classes
      .to_owned()
      .unwrap()
      .contains(&UsageClassType::CapacityBlock);
    let cpu_arches = inst.processor_info.to_owned().unwrap().supported_architectures.unwrap();
    let cpu_arch = if cpu_arches.contains(&ArchitectureType::Arm64) | cpu_arches.contains(&ArchitectureType::Arm64Mac) {
      "arm64".to_owned()
    } else if cpu_arches.contains(&ArchitectureType::X8664) | cpu_arches.contains(&ArchitectureType::X8664Mac) {
      "x86-64".to_owned()
    } else {
      "unknown".to_owned()
    };

    let instance_type = inst.instance_type.to_owned().unwrap().as_str().to_owned();
    instances.insert(
      instance_type.clone(),
      InstanceInfo {
        instance_type,
        instance_storage_supported: inst.instance_storage_supported.unwrap(),
        efa_supported,
        nvidia_gpu_supported,
        neuron_supported,
        cbr_supported,
        cpu_arch,
      },
    );
  }

  Ok(instances)
}

/// Collect the EC2 instance details and populate the instances.rs file
async fn update_ec2_instances() -> Result<()> {
  let regions = vec!["us-east-1", "us-east-2", "us-west-2"];
  let mut instances: BTreeMap<String, InstanceInfo> = BTreeMap::new();

  // Not GA and requires allow listing
  instances.insert(
    "p4de.24xlarge".to_owned(),
    InstanceInfo {
      instance_type: "p4de.24xlarge".to_owned(),
      instance_storage_supported: true,
      efa_supported: true,
      nvidia_gpu_supported: true,
      neuron_supported: false,
      cbr_supported: false,
      cpu_arch: "x86-64".to_owned(),
    },
  );

  for region in regions {
    instances = get_ec2_instances(Region::new(region.to_owned()), instances).await?;
  }

  let reg = Handlebars::new();
  let rendered = reg.render_template(EC2_INSTANCES_TEMPLATE, &json!({"instances": instances}))?;

  let mut file = fs::OpenOptions::new()
    .create(true)
    .truncate(true)
    .write(true)
    .open("./cookiecluster/src/inputs/instance.rs")?;

  file.write_all(rendered.as_bytes())?;

  Ok(())
}
